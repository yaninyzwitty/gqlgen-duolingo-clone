package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/yaninyzwitty/gqlgen-duolingo-clone/graph/model"
	"github.com/yaninyzwitty/gqlgen-duolingo-clone/internal/helpers"
)

// Lesson is the resolver for the lesson field.
func (r *challengeResolver) Lesson(ctx context.Context, obj *model.Challenge) (*model.Lesson, error) {
	panic(fmt.Errorf("not implemented: Lesson - lesson"))
}

// Type is the resolver for the type field.
func (r *challengeResolver) Type(ctx context.Context, obj *model.Challenge) (model.ChallengeType, error) {
	panic(fmt.Errorf("not implemented: Type - type"))
}

// Units is the resolver for the units field.
func (r *courseResolver) Units(ctx context.Context, obj *model.Course) ([]*model.Unit, error) {
	courseID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid course ID (%s): %w", obj.ID, err)
	}

	query := `
	SELECT id, title, description, unit_order
	FROM units
	WHERE course_id = $1
	ORDER BY unit_order ASC
`
	rows, err := r.Pool.Query(ctx, query, courseID)
	if err != nil {
		return nil, fmt.Errorf("failed to query units for course %s: %w", obj.ID, err)
	}
	defer rows.Close()

	var units []*model.Unit
	for rows.Next() {
		var (
			id          uuid.UUID
			title       string
			description string
			unitOrder   int
			courseID    uuid.UUID
		)

		if err := rows.Scan(&id, &title, &description, &unitOrder, &courseID); err != nil {
			return nil, fmt.Errorf("failed to scan unit row: %w", err)
		}
		units = append(units, &model.Unit{
			ID:          id.String(),
			Title:       title,
			Description: description,
			Course:      nil,
			Order:       int32(unitOrder),
		})

	}
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %w", err)
	}
	return units, nil

}

// Edges is the resolver for the edges field.
func (r *courseConnectionResolver) Edges(ctx context.Context, obj *model.CourseConnection) ([]*model.CourseEdge, error) {
	panic(fmt.Errorf("not implemented: Edges - edges"))
}

// PageInfo is the resolver for the pageInfo field.
func (r *courseConnectionResolver) PageInfo(ctx context.Context, obj *model.CourseConnection) (*model.PageInfo, error) {
	panic(fmt.Errorf("not implemented: PageInfo - pageInfo"))
}

// Node is the resolver for the node field.
func (r *courseEdgeResolver) Node(ctx context.Context, obj *model.CourseEdge) (*model.Course, error) {
	panic(fmt.Errorf("not implemented: Node - node"))
}

// Unit is the resolver for the unit field.
func (r *lessonResolver) Unit(ctx context.Context, obj *model.Lesson) (*model.Unit, error) {
	panic(fmt.Errorf("not implemented: Unit - unit"))
}

// AddCourse is the resolver for the addCourse field.
func (r *mutationResolver) AddCourse(ctx context.Context, title string, imageSrc string) (*model.Course, error) {
	if title == "" || imageSrc == "" {
		return nil, fmt.Errorf("both title and imageSrc are required")

	}

	var titleRes, imageSrcRes string
	var id uuid.UUID
	query := `INSERT INTO courses (title, image_src) VALUES($1, $2) RETURNING id, title, image_src`
	if err := r.Pool.QueryRow(ctx, query, title, imageSrc).Scan(&id, &titleRes, &imageSrcRes); err != nil {
		return nil, fmt.Errorf("failed to insert course: %w", err)
	}
	return &model.Course{
		ID:       id.String(),
		Title:    titleRes,
		ImageSrc: imageSrcRes,
		Units:    []*model.Unit{},
	}, nil

}

// UpdateCourse is the resolver for the updateCourse field.
func (r *mutationResolver) UpdateCourse(ctx context.Context, id string, title *string, imageSrc *string) (*model.Course, error) {
	courseID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("failed to parse course id: %w", err)
	}

	query := "UPDATE courses SET"
	var args []interface{}
	argIndex := 1

	if title != nil {
		query += fmt.Sprintf(" title = $%d,", argIndex)
		args = append(args, *title)
		argIndex++
	}

	if imageSrc != nil {
		query += fmt.Sprintf(" image_src = $%d,", argIndex)
		args = append(args, *imageSrc)
		argIndex++
	}

	// Ensure at least one field was updated
	if len(args) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	// Remove the trailing comma and add the WHERE clause
	query = query[:len(query)-1] // remove trailing comma
	query += fmt.Sprintf(" WHERE id = $%d RETURNING id, title, image_src", argIndex)
	args = append(args, courseID)

	// Execute the query and scan the result
	var titleRes, imageSrcRes string
	var courseResID uuid.UUID
	err = r.Pool.QueryRow(ctx, query, args...).Scan(&courseResID, &titleRes, &imageSrcRes)
	if err != nil {
		return nil, fmt.Errorf("failed to update course: %w", err)
	}

	// Return the updated course
	return &model.Course{
		ID:       courseResID.String(),
		Title:    titleRes,
		ImageSrc: imageSrcRes,
		Units:    nil, // or provide units if available
	}, nil
}

// DeleteCourse is the resolver for the deleteCourse field.
func (r *mutationResolver) DeleteCourse(ctx context.Context, id string) (*bool, error) {
	if id == "" {
		return nil, fmt.Errorf("course id is required")
	}

	// Parse the course ID
	courseID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("failed to parse course id into UUID: %w", err)
	}

	// Define the DELETE query
	query := `DELETE FROM courses WHERE id = $1`

	// Execute the DELETE query
	res, err := r.Pool.Exec(ctx, query, courseID)
	if err != nil {
		return nil, fmt.Errorf("failed to execute delete query: %w", err)
	}

	// Check if the course was found and deleted
	if res.RowsAffected() == 0 {
		return nil, fmt.Errorf("course with id %s not found", id)
	}

	// Return success
	success := true
	return &success, nil
}

// AddUnit is the resolver for the addUnit field.
func (r *mutationResolver) AddUnit(ctx context.Context, title string, description string, courseID string, order int32) (*model.Unit, error) {
	if title == "" || description == "" || courseID == "" {
		return nil, fmt.Errorf("title, description, and courseID are required")
	}

	// Parse the courseID into UUID format
	courseId, err := uuid.Parse(courseID)
	if err != nil {
		return nil, fmt.Errorf("failed to parse the course id into uuid: %w", err)
	}

	// Insert the new unit into the units table
	query := `INSERT INTO units (title, description, course_id) VALUES($1, $2, $3) RETURNING id, title, description, course_id, unit_order`
	var ID, courseIDRes uuid.UUID
	var titleRes, descriptionRes string
	var unitOrder int32

	err = r.Pool.QueryRow(ctx, query, title, description, courseId).Scan(&ID, &titleRes, &descriptionRes, &courseIDRes, &unitOrder)
	if err != nil {
		return nil, fmt.Errorf("failed to insert unit: %w", err)
	}

	// Return the newly created unit
	return &model.Unit{
		ID:          ID.String(),
		Title:       titleRes,
		Description: descriptionRes,
		Course:      nil, // You can populate this with the full course if needed
		Order:       unitOrder,
	}, nil
}

// UpdateUnit is the resolver for the updateUnit field.
func (r *mutationResolver) UpdateUnit(ctx context.Context, id string, title *string, description *string, order *int32) (*model.Unit, error) {
	panic(fmt.Errorf("not implemented: UpdateUnit - updateUnit"))
}

// DeleteUnit is the resolver for the deleteUnit field.
func (r *mutationResolver) DeleteUnit(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUnit - deleteUnit"))
}

// AddLesson is the resolver for the addLesson field.
func (r *mutationResolver) AddLesson(ctx context.Context, title string, unitID string, order int32) (*model.Lesson, error) {
	panic(fmt.Errorf("not implemented: AddLesson - addLesson"))
}

// UpdateLesson is the resolver for the updateLesson field.
func (r *mutationResolver) UpdateLesson(ctx context.Context, id string, title *string, order *int32) (*model.Lesson, error) {
	panic(fmt.Errorf("not implemented: UpdateLesson - updateLesson"))
}

// DeleteLesson is the resolver for the deleteLesson field.
func (r *mutationResolver) DeleteLesson(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteLesson - deleteLesson"))
}

// AddChallenge is the resolver for the addChallenge field.
func (r *mutationResolver) AddChallenge(ctx context.Context, lessonID string, typeArg model.ChallengeType, question string, order int32) (*model.Challenge, error) {
	panic(fmt.Errorf("not implemented: AddChallenge - addChallenge"))
}

// UpdateChallenge is the resolver for the updateChallenge field.
func (r *mutationResolver) UpdateChallenge(ctx context.Context, id string, typeArg *model.ChallengeType, question *string, order *int32) (*model.Challenge, error) {
	panic(fmt.Errorf("not implemented: UpdateChallenge - updateChallenge"))
}

// DeleteChallenge is the resolver for the deleteChallenge field.
func (r *mutationResolver) DeleteChallenge(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteChallenge - deleteChallenge"))
}

// AddUserProgress is the resolver for the addUserProgress field.
func (r *mutationResolver) AddUserProgress(ctx context.Context, userID string, userName string, activeCourseID *string, hearts int32, points int32) (*model.UserProgress, error) {
	panic(fmt.Errorf("not implemented: AddUserProgress - addUserProgress"))
}

// UpdateUserProgress is the resolver for the updateUserProgress field.
func (r *mutationResolver) UpdateUserProgress(ctx context.Context, userID string, userName *string, activeCourseID *string, hearts *int32, points *int32) (*model.UserProgress, error) {
	panic(fmt.Errorf("not implemented: UpdateUserProgress - updateUserProgress"))
}

// DeleteUserProgress is the resolver for the deleteUserProgress field.
func (r *mutationResolver) DeleteUserProgress(ctx context.Context, userID string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUserProgress - deleteUserProgress"))
}

// UpsertUserProgress is the resolver for the upsertUserProgress field.
func (r *mutationResolver) UpsertUserProgress(ctx context.Context, courseID int32) (*model.UserProgress, error) {
	panic(fmt.Errorf("not implemented: UpsertUserProgress - upsertUserProgress"))
}

// ReduceHearts is the resolver for the reduceHearts field.
func (r *mutationResolver) ReduceHearts(ctx context.Context, challengeID int32) (*model.UserProgressResponse, error) {
	panic(fmt.Errorf("not implemented: ReduceHearts - reduceHearts"))
}

// RefillHearts is the resolver for the refillHearts field.
func (r *mutationResolver) RefillHearts(ctx context.Context) (*model.UserProgress, error) {
	panic(fmt.Errorf("not implemented: RefillHearts - refillHearts"))
}

// UpsertChallengeProgress is the resolver for the upsertChallengeProgress field.
func (r *mutationResolver) UpsertChallengeProgress(ctx context.Context, challengeID int32) (*model.UserProgress, error) {
	panic(fmt.Errorf("not implemented: UpsertChallengeProgress - upsertChallengeProgress"))
}

// Courses is the resolver for the courses field.
func (r *queryResolver) Courses(ctx context.Context, limit *int32, offset *int32) ([]*model.Course, error) {
	l := int32(10) // Default limit
	o := int32(0)  // Default offset

	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	query := `
        SELECT id, title, image_src, created_at
        FROM courses
        ORDER BY created_at ASC
        LIMIT $1 OFFSET $2
    `

	rows, err := r.Pool.Query(ctx, query, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to get courses: %w", err)
	}
	defer rows.Close()

	var courses []*model.Course
	for rows.Next() {
		var course model.Course
		var courseID uuid.UUID
		var createdAt time.Time
		if err := rows.Scan(&courseID, &course.Title, &course.ImageSrc, &createdAt); err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		courses = append(courses, &model.Course{
			ID:       courseID.String(),
			Title:    course.Title,
			ImageSrc: course.ImageSrc,
			Units:    nil,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows iteration error: %w", err)
	}

	return courses, nil
}

// Course is the resolver for the course field.
func (r *queryResolver) Course(ctx context.Context, id string) (*model.Course, error) {
	courseID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("failed to parse course id: %w", err)

	}

	query := `SELECT id, title, image_src FROM courses WHERE id = $1`

	var ID uuid.UUID
	var title, imageSrc string

	err = r.Pool.QueryRow(ctx, query, courseID).Scan(&ID, &title, &imageSrc)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, nil // Return nil if no course found
		}
		return nil, fmt.Errorf("failed to get course: %w", err)

	}

	return &model.Course{
		ID:       ID.String(),
		Title:    title,
		ImageSrc: imageSrc,
		Units:    nil,
	}, nil

}

// Units is the resolver for the units field.
func (r *queryResolver) Units(ctx context.Context, limit *int32, offset *int32) ([]*model.Unit, error) {
	l := int32(10) // Default limit
	o := int32(0)  // Default offset

	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	query := `
        SELECT id, title, description, course_id, unit_order, created_at
        FROM units
        ORDER BY created_at ASC
        LIMIT $1 OFFSET $2
    `

	rows, err := r.Pool.Query(ctx, query, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to query database: %w", err)
	}
	defer rows.Close()

	var units []*model.Unit

	for rows.Next() {
		var unit model.Unit
		var unitID, courseID uuid.UUID
		var createdAt time.Time
		if err := rows.Scan(&unitID, &unit.Title, &unit.Description, &courseID, &unit.Order, &createdAt); err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		units = append(units, &model.Unit{
			ID:          unitID.String(),
			Title:       unit.Title,
			Description: unit.Description,
			Course:      nil, // gqlgen will resolve this field using the resolver function
			Order:       unit.Order,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows iteration error: %w", err)
	}

	return units, nil
}

// Unit is the resolver for the unit field.
func (r *queryResolver) Unit(ctx context.Context, id string) (*model.Unit, error) {
	unitID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("failed to parse unit id: %w", err)
	}

	query := `
        SELECT
            id, title, description, course_id, unit_order
        FROM units
        WHERE id = $1
    `

	var ID, courseID uuid.UUID
	var title, description string
	var unitOrder int32

	if err := r.Pool.QueryRow(ctx, query, unitID).Scan(&ID, &title, &description, &courseID, &unitOrder); err != nil {
		if err == pgx.ErrNoRows {
			return nil, nil // Return nil if no unit found
		}
		return nil, fmt.Errorf("failed to get unit: %w", err)
	}

	return &model.Unit{
		ID:          ID.String(),
		Title:       title,
		Description: description,
		Course:      nil,
		Order:       unitOrder,
	}, nil
}

// PaginatedCourses is the resolver for the paginatedCourses field.
func (r *queryResolver) PaginatedCourses(ctx context.Context, first *int32, after *string) (*model.CourseConnection, error) {
	limit := int32(10) // Default limit
	offset := int32(0) // Default offset

	if first != nil {
		limit = *first
	}

	if after != nil {
		decodeOffset, err := helpers.DecodeCursor(*after)
		if err != nil {
			return nil, fmt.Errorf("failed to decode cursor: %w", err)
		}
		offset = decodeOffset
	}

	query := `
        SELECT id, title, image_src, created_at
        FROM courses
        ORDER BY created_at ASC
        LIMIT $1 OFFSET $2
    `

	rows, err := r.Pool.Query(ctx, query, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to query database: %w", err)
	}
	defer rows.Close()

	var edges []*model.CourseEdge
	var lastOffset int32 = offset

	for rows.Next() {
		var course model.Course
		var courseID uuid.UUID
		var createdAt time.Time

		if err := rows.Scan(&courseID, &course.Title, &course.ImageSrc, &createdAt); err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		edge := model.CourseEdge{
			Node: &model.Course{
				ID:       courseID.String(),
				Title:    course.Title,
				ImageSrc: course.ImageSrc,
				Units:    nil,
			},
			Cursor: helpers.EncodeCursor(lastOffset),
		}

		edges = append(edges, &edge)
		lastOffset++
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %w", err)
	}

	var hasNextPage bool

	nextQuery := `
        SELECT COUNT(1) > 0
        FROM courses
        WHERE created_at > (
            SELECT created_at
            FROM courses
            ORDER BY created_at ASC
            LIMIT 1 OFFSET $1
        )
    `
	err = r.Pool.QueryRow(ctx, nextQuery, lastOffset).Scan(&hasNextPage)
	if err != nil {
		return nil, fmt.Errorf("failed to check next page: %w", err)
	}

	pageInfo := model.PageInfo{
		HasNextPage: hasNextPage,
		EndCursor:   helpers.EncodeCursor(lastOffset),
	}

	return &model.CourseConnection{
		Edges:    edges,
		PageInfo: &pageInfo,
	}, nil
}

// Course is the resolver for the course field.
func (r *unitResolver) Course(ctx context.Context, obj *model.Unit) (*model.Course, error) {

	courseID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to parse course id: %w", err)
	}

	query := `SELECT id, title, image_src FROM courses WHERE id = $1`
	var courseIDRes uuid.UUID
	var title, imageSrc string
	err = r.Pool.QueryRow(ctx, query, courseID).Scan(&courseIDRes, &title, &imageSrc)
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, nil // Return nil if no course found
		}
		return nil, fmt.Errorf("failed to get course: %w", err)
	}

	return &model.Course{
		ID:       courseIDRes.String(),
		Title:    title,
		ImageSrc: imageSrc,
		Units:    nil, // Units can be populated if needed, add a resolver for them
	}, nil

}

// ActiveCourse is the resolver for the activeCourse field.
func (r *userProgressResolver) ActiveCourse(ctx context.Context, obj *model.UserProgress) (*model.Course, error) {
	panic(fmt.Errorf("not implemented: ActiveCourse - activeCourse"))
}

// UserProgress is the resolver for the userProgress field.
func (r *userProgressResponseResolver) UserProgress(ctx context.Context, obj *model.UserProgressResponse) (*model.UserProgress, error) {
	panic(fmt.Errorf("not implemented: UserProgress - userProgress"))
}

// Challenge returns ChallengeResolver implementation.
func (r *Resolver) Challenge() ChallengeResolver { return &challengeResolver{r} }

// Course returns CourseResolver implementation.
func (r *Resolver) Course() CourseResolver { return &courseResolver{r} }

// CourseConnection returns CourseConnectionResolver implementation.
func (r *Resolver) CourseConnection() CourseConnectionResolver { return &courseConnectionResolver{r} }

// CourseEdge returns CourseEdgeResolver implementation.
func (r *Resolver) CourseEdge() CourseEdgeResolver { return &courseEdgeResolver{r} }

// Lesson returns LessonResolver implementation.
func (r *Resolver) Lesson() LessonResolver { return &lessonResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Unit returns UnitResolver implementation.
func (r *Resolver) Unit() UnitResolver { return &unitResolver{r} }

// UserProgress returns UserProgressResolver implementation.
func (r *Resolver) UserProgress() UserProgressResolver { return &userProgressResolver{r} }

// UserProgressResponse returns UserProgressResponseResolver implementation.
func (r *Resolver) UserProgressResponse() UserProgressResponseResolver {
	return &userProgressResponseResolver{r}
}

type challengeResolver struct{ *Resolver }
type courseResolver struct{ *Resolver }
type courseConnectionResolver struct{ *Resolver }
type courseEdgeResolver struct{ *Resolver }
type lessonResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type unitResolver struct{ *Resolver }
type userProgressResolver struct{ *Resolver }
type userProgressResponseResolver struct{ *Resolver }
